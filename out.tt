Object [

in: object at: index [
	" browse instance variable via debugger "
	<24 object index>.
	self primitiveFailed]
isNil [
	^ false]
notNil [
	^ true]
== arg [
	<1 self arg>]
= arg [
	^ self == arg]
~= arg [
	^ (self = arg) not]
~~ arg [
	^ (self == arg) not]
class [
	<2 self>]
printString [
	^ self class printString]
isMemberOf: aClass [
	^ self class == aClass]
isKindOf: aClass	| clas | [
	clas <- self class.
	[ clas notNil ] whileTrue:
		[ clas == aClass ifTrue: [ ^ true ].
		  clas <- clas superclass ].
	^ false]
respondsTo: aMessage [
	^ self class allMethods includes: aMessage]
print [
	self printString do: [ :c | c print ]]
printNl [
	self print. Char newline print]
question: text	| answer | [
	text print.
	answer <- String input.
	(answer notNil)
		ifTrue: [ answer <- answer at: 1 ifAbsent: [ $n ] ].
	^ answer = $y or: [ answer = $Y]]
error: str [
		" print the message "
	str printNl.
		" then halt "
	<19>]
debug [
	<18>]
primitiveFailed [
	self error: 'Primitive failed']
species [
	" By default, we re-instantiate ourselves as our own Class "
	^ self class]
hash [
	" Most objects should generate something based on their value "
	^ self class printString hash]
become: other [
	" Exchange identity with another object "
	(Array with: self) elementsExchangeIdentityWith: (Array with: other)]
doesNotUnderstand: aSel [
	self error: (self printString + ' (class '+
		(self class printString) +
		'): does not understand ' + aSel printString)]
basicSize [
	<4 self>.
	self primitiveFailed]
subclassResponsibility [
	self error: 'Subclass responsibility']
basicDo: aBlock [
	^ self do: aBlock]
]

Class [

name: n parent: c variables: v [
	" create a new class with the given characteristics "
	name <- n.
	parentClass <- c.
	methods <- Dictionary new.
	size <- v size + c size.
	variables <- v]
size [
	^ size]
superclass [
	^ parentClass]
variables [
	^ variables]
subclasses [
	self subclasses: 0]
subclasses: indent [
	globals do: [ :obj |
		((obj isKindOf: Class) and: [ obj superclass == self])
			ifTrue: [
				1 to: indent do: [:ignore| $  print ].
				obj printNl.
				obj subclasses: indent + 4 ] ]]
listMethods [
	methods keysDo:
		[ :name | name printNl ]]
allMethods | allMethods | [
	parentClass isNil
		ifTrue: [ allMethods <- Dictionary new ]
		ifFalse: [ allMethods <- parentClass allMethods ].
	methods binaryDo: [ :n :m | allMethods at: n put: m ].
	^ allMethods]
listAllMethods [
	self allMethods keysDo: [:n| n printNl ]]
viewMethod: nm  | meth | [
	meth <- self allMethods at: nm
		ifAbsent: [ ^ self error: 'no such method'].
	meth text print.
	^ '']
editMethod: nm	| meth text | [
	meth <- methods at: nm
		ifAbsent: [ ^ self error: 'no such method'].
	text <- meth text edit.
	(self question: 'compile method?')
		ifTrue: [ self addMethod: text ]]
subclass: nm [
	^ self subclass: nm variables: (Array new: 0)
		classVariables: (Array new: 0)]
subclass: nm variables: v [
	^ self subclass: nm variables: v classVariables: (Array new: 0)]
subclass: nm variables: v classVariables: cv | meta | [
	meta <- Class new name: ('Meta' + nm asString) asSymbol
		parent: self class
		variables: cv.
	globals at: nm put: ( meta new name: nm
		parent: self
		variables: v ).
	^ 'subclass created: ' + nm printString]
addMethod	| text | [
	text <- ' ' edit.
	(self question: 'compile method?')
		ifTrue: [ self addMethod: text ]]
addMethod: text | meth | [
	meth <- self parseMethod: text.
	meth notNil ifTrue: [
		methods at: meth name put: meth.
		Method flushCache.
		'ok' printNl.
		^ meth
	].
	^ nil]
removeMethod: methName [
	methods removeKey: methName ifAbsent: [
		self error: 'Method not present: ' + (methName printString)
	].
	Method flushCache.]
view: methodName [
		" print the text of the given method "
	(methods at: methodName
		ifAbsent: [ ^ self error: 'no such method'])
			text print]
parseMethod: text [
	^ (Parser new
		text: text instanceVars: self instanceVariables) parse: self]
new [
	" return a new instance of ourselves "
	<7 self size>]
basicNew [
	" Like new "
	<7 self size>]
instanceVariables	| names | [
		" return all our variable names "
	parentClass notNil
		ifTrue: [ names <- parentClass instanceVariables ]
		ifFalse: [ names <- Array new: 0 ].
	(variables isNil or: [ variables isEmpty ])
		ifFalse: [ names <- names + variables ].
	^ names]
methods [
	" return the tree of methods "
	^ methods]
printString [
	" just return our name "
	^ name printString]
isMeta [
	^ (name asString from: 1 to: 4) = 'Meta']
fileOut: f | tag | [
	self isMeta ifTrue: [
		tag <- '=' + (name asString from: 5 to: 99)
	] ifFalse: [
		tag <- '!' + name asString
	].
	tag <- tag + String newline.
	methods do: [:m|
		f write: tag.
		f write: (m text printString).
		f write: ('!' + String newline)
	]]
fileOut | f | [
	f <- File openWrite: (name printString + '.st').
	f isNil ifTrue: [ self error: 'File creation failed' ].
	self isMeta ifFalse: [
		self class fileOut: f
	].
	self fileOut: f.
	f close]
]

MetaObject [

in: object at: index put: value [
	" change data field in object, used during initialization "
	" returns the intialized object "
	<5 value object index>]
]

MetaClass [

]

Undefined [

printString [
	^ 'nil']
isNil [
	" yes, we are nil "
	^ true]
notNil [
	" no, we are not not-nil "
	^ false]
main	| command | [
	" initialize classes "
	Char initialize.]
]

MetaUndefined [

new [
	" there is only one nil object "
	^ nil]
]

Boolean [

and: aBlock [
	^ self
		ifTrue: [ aBlock value ]
		ifFalse: [ false ]]
or: aBlock [
	^ self
		ifTrue: [ true ]
		ifFalse: [ aBlock value ]]
not [
	^ self
		ifTrue: [ false ]
		ifFalse: [ true ]]
ifFalse: falseBlock ifTrue: trueBlock [
	^ self ifTrue: [ trueBlock  value ] ifFalse: [ falseBlock value ]]
ifTrue: aBlock [
	^ self ifTrue: [ aBlock value ] ifFalse: [ nil ]]
ifFalse: aBlock [
	^ self ifTrue: [ nil ] ifFalse: [ aBlock value ]]
]

MetaBoolean [

]

True [

not [
	^ false]
printString [
	^ 'true']
ifTrue: trueBlock ifFalse: falseBlock [
	^ trueBlock value]
or: aBlock [
	^ true]
and: aBlock [
	^ aBlock value]
]

MetaTrue [

new [
	" there is only one true value "
	^ true]
]

False [

not [
	^ true]
printString [
	^ 'false']
ifTrue: trueBlock ifFalse: falseBlock [
	^ falseBlock value]
or: aBlock [
	^ aBlock value]
and: aBlock [
	^ false]
]

MetaFalse [

new [
	" there is only one false value "
	^ false]
]

Process [

doExecute: ticks [
	<6 self ticks>]
context: aContext [
	context <- aContext]
context [
	^ context]
execute | r | [
	r <- self doExecute: 0.
	(r = 3) ifTrue: [
		" Note: state field is filled in with arguments on error "
		(state at: 1) print. ' (class ' print.
		(state at: 1) class print. ') ' print.
		'does not understand: ' print.  result printNl
	].
	(r = 4) ifTrue: [ ^ result ]
		ifFalse: [ 'Backtrace:' printNl.
			context backtrace. ^ nil ]]
]

MetaProcess [

]

Context [

setup: aMethod withArguments: a [
	method <- aMethod.
	arguments <- Array new: 1.
	bytePointer <- 0.
	stack <- Array new: method stackSize.
	stackTop <- 0.
	temporaries <- Array new: method temporarySize.]
perform: aMethod withArguments: a | proc | [
	self setup: aMethod withArguments: a.
	proc <- Process new.
	proc context: self.
	^ proc execute]
backtrace | narg | [
		" backtrace context calls "
	narg <- 0.
	method name print.
	'(' print.
	arguments do: [:a |
		(narg > 0) ifTrue: [ ', ' print ].
		a class print.
		narg <- narg+1
	].
	')' printNl.
	previousContext notNil
		ifTrue: [ previousContext backtrace ]]
previousContext [
	^ previousContext]
]

MetaContext [

]

Block [

argCount [
	self error: 'Incorrect argument passing to Block']
value [
	" start block execution "
	<8 self>
	(self argCount)]
value: a [
	" start block execution "
	<8 a self>
	(self argCount)]
value: a value: b [
	" start block execution "
	<8 a b self>
	(self argCount)]
whileTrue: aBlock [
	self value ifTrue: [ aBlock value. ^ self whileTrue: aBlock ]]
whileFalse: aBlock [
	self value ifFalse: [ aBlock value. ^ self whileFalse: aBlock ]]
backtrace | narg | [
		" backtrace context calls "
	'block from ' print. method name print.
	'(' print.
	narg <- 0.
	arguments do: [:a |
		(narg > 0) ifTrue: [', ' print ].
		a class print.
		narg <- narg+1
	].
	')' printNl.
	previousContext notNil
		ifTrue: [ previousContext backtrace ]]
]

MetaBlock [

]

Method [

byteCodes [
	^ byteCodes]
literals [
	^ literals]
text [
	^ text]
name [
	^ name]
stackSize [
	^ stackSize]
temporarySize [
	^temporarySize]
args: argNames inst: instNames temp: tempNames [
	" Hook for recording symbolic debug "]
]

MetaMethod [

name: n byteCodes: b literals: l stackSize: s temporarySize: ts class: c text: t [
	| newMethod |
	newMethod <- self new.
	super in: newMethod at: 1 put: n.
	super in: newMethod at: 2 put: b.
	super in: newMethod at: 3 put: l.
	super in: newMethod at: 4 put: s.
	super in: newMethod at: 5 put: ts.
	super in: newMethod at: 6 put: c.
	super in: newMethod at: 7 put: t.
	^ newMethod]
flushCache [
	<34>.
	self primitiveFailed]
]

Magnitude [

<= arg [
	^ self < arg or: [ self = arg ]]
> arg [
	^ arg < self]
>= arg [
	^ (self > arg) or: [ self = arg ]]
min: arg [
	^ self < arg ifTrue: [ self ] ifFalse: [ arg ]]
max: arg [
	^ self < arg ifTrue: [ arg ] ifFalse: [ self ]]
between: low and: high [
	^ low <= self and: [ self <= high ]]
]

MetaMagnitude [

]

MetaSymbol [

intern: string [
	<23 string Symbol>]
new: fromString | sym | [
	^ symbols at: fromString
		ifAbsent: [ symbols add: (self intern: fromString) ]]
]

Symbol [

printString [
	<23 self String>]
asString [
	^self printString]
hash [
	^self printString hash]
asSymbol [
	^self]
= aString [
		" works with either symbol or string arguments "
	^ self printString = aString printString]
< arg [
		" works with either symbol or string arguments "
	^ self printString < arg printString]
]

MetaChar [

initialize [
	chars isNil ifTrue: [
		chars <- Array new: 257.
		1 to: 257 do: [:idx|
			chars at: idx put: (Char basicNew: idx-1)
		]
	]]
basicNew: value [
	" create and initialize a new char "
	^ self in: self new at: 1 put: value]
new: value [
	" return unique Char for ASCII value (or EOF) "
	(value < 257) ifTrue: [ ^ chars at: value+1 ].]
newline [
		" return newline character "
	^ self new: 10]
tab [
		" return tab character "
	^ self new: 9]
eof [
		" return an EOF indication--not a true Char, but polymorphic "
	^ self new: 256]
doInput [
	<9>]
input	| c | [
	" read a single char from input stream "
	c <- self doInput.
	(c notNil)
		ifTrue: [ ^self new: c ]
		ifFalse: [ ^nil ]]
]

Char [

value [
		" return our ascii value as an integer "
	^ value]
hash [
	^ value]
isDigit [
	^ self between: $0 and: $9]
isLowerCase [
	^ self between: $a and: $z]
isUpperCase [
	^ self between: $A and: $Z]
isAlphabetic [
	^ self isLowerCase or: [ self isUpperCase ]]
isEOF [
	^ value = 256]
lowerCase [
	self isUpperCase
		ifTrue: [ ^ Char new: (value - 65) + 97 ]]
upperCase [
	self isLowerCase
		ifTrue: [ ^ Char new: (value - 97) + 65 ]]
isAlphanumeric [
		" are we a letter or a digit? "
	^ self isAlphabetic or: [ self isDigit ]]
isBlank [
		"spaces, tabs and newlines are all blank"
	^ value = 32 or: [ value = 9 or: [ value = 10 ] ]]
print [
	<3 value>]
asString [
	" return char as a string value "
	^ String new: 1; at: 1 put: self]
printString [
	^ String new: 2; at: 1 put: $$ ; at: 2 put: self]
= aChar [
	^ value = aChar value]
< aChar [
	^ value < aChar value]
]

Collection [

noElement [
	self error: 'Element not present']
size	| tally | [
	tally <- 0.
	self do: [:i | tally <- tally + 1].
	^ tally]
isEmpty [
		" empty if there are no elements "
	^ self size = 0]
at: value ifAbsent: exceptionBlock [
	self do: [ :element | element = value ifTrue: [ ^ element ]].
	^ exceptionBlock value]
at: value [
	^ self at: value ifAbsent: [ self noElement ]]
includes: value [
	self at: value ifAbsent: [ ^ false ].
	^ true]
asArray		| newArray index | [
	newArray <- Array new: self size.
	index <- 1.
	self do: [ :element | newArray at: index put: element.
		index <- index + 1 ].
	^ newArray]
from: argLow to: argHigh | ret idx size base low high | [
	low <- argLow max: 1.
	high <- argHigh min: self size.
	size <- (high - low) + 1.
	(size < 1) ifTrue: [ ^ Array new: 0 ].
	ret <- Array new: size.
	base <- idx <- 1.
	self do: [:elem|
		((idx >= low) and: [idx <= high]) ifTrue: [
			ret at: base put: elem.
			base <- base + 1.
			(base > size) ifTrue: [ ^ ret ]
		].
		idx <- idx + 1.
	].
	^ ret]
from: argLow [
	^ self from: argLow to: (self size)]
asString	| newString index | [
	newString <- String new: self size.
	index <- 1.
	self do: [ :element | newString at: index put: element.
		index <- index + 1 ].
	^ newString]
asList [
	^ List new addAll: self]
collect: transformBlock	| newList | [
	newList <- List new.
	self do: [:element | newList addLast: (transformBlock value: element)].
	^ newList]
select: testBlock	| newList | [
	newList <- List new.
	self do: [:x | (testBlock value: x) ifTrue: [newList addLast: x]].
	^ newList]
< aCollection [
	self do: [ :element | (aCollection includes: element)
		ifFalse: [ ^ false ] ].
	^ true]
= aCollection [
	^ self < aCollection and: [ aCollection < self ]]
reject: testBlock [
		" select the things that do not match predicate "
	^ self select: [:x | (testBlock value: x) not ]]
printString | count res | [
	res <- super printString.
	(self respondsTo: #do:) ifFalse: [ ^ res ].
	count <- 0.
	res <- res + ' ('.
	self basicDo: [:elem|
		(count = 0) ifFalse: [ res <- res + ' ' ].
		res <- res + elem printString.
		count <- count + 1.
		(count >= 20) ifTrue: [ ^ res + ' ...)' ]
	].
	^ res + ')']
occurencesOf: obj | count | [
	count <- 0.
	self do: [:o| (o = obj) ifTrue: [ count <- count + 1]].
	^ count]
anyOne [
	self do: [:it| ^ it].
	self emptyCollection]
emptyCollection [
	self error: (self class printString + ' is empty')]
do: aBlock [
	self subclassResponsibility]
]

MetaCollection [

]

List [

add: anElement [
	elements <- Link value: anElement next: elements.
	^ anElement]
addLast: anElement [
	elements isNil
		ifTrue: [ self add: anElement]
		ifFalse: [ elements addLast: anElement ].
	^ anElement]
addAll: aCollection [
	aCollection do: [ :element | self addLast: element ]]
+ aCollection [
	^ self addAll: aCollection]
copy [
	^ self asList]
badIndex [
	self error: 'Invalid List index']
findLink: index ifAbsent: aBlock | idx link | [
	link <- elements.
	idx <- index.
	link isNil ifTrue: [ ^ aBlock value ].
	[ link notNil ] whileTrue: [
		idx <- idx-1.
		(idx = 0) ifTrue: [ ^ link ].
		link <- link next
	].
	^ aBlock value]
at: index | link | [
	link <- self findLink: index ifAbsent: [ self badIndex ].
	^ link value]
at: index ifAbsent: aBlock | link | [
	link <- self findLink: index ifAbsent: [nil].
	link isNil ifTrue: [ ^ aBlock value ].
	^ link value]
at: index put: value | link | [
	link <- self findLink: index.
	link value: value]
first [
	^ self at: 1]
isEmpty [
	^ elements isNil]
removeFirst [
	elements isNil
		ifTrue: [ self emptyCollection ]
		ifFalse: [ elements <- elements next ]]
remove: anElement [
	self remove: anElement
		ifAbsent: [ self emptyCollection ]]
reverse | newList | [
	newList <- List new.
	self do: [ :element | newList add: element ].
	^ newList]
remove: anElement ifAbsent: exceptionBlock [
	elements isNil
		ifTrue: [ exceptionBlock value ]
		ifFalse: [ elements remove: anElement ifAbsent: exceptionBlock ]]
do: aBlock [
	^ elements notNil ifTrue: [ elements do: aBlock ]]
reverseDo: aBlock [
	^ elements notNil ifTrue: [ elements reverseDo: aBlock ]]
select: testBlock | newList | [
	newList <- List new.
	self reverseDo: [:element | (testBlock value: element)
		ifTrue: [ newList add: element ] ].
	^ newList]
]

MetaList [

with: elemA	| newList | [
	newList <- self new.
	newList add: elemA.
	^ newList]
with: elemA with: elemB	| newList | [
	newList <- self new.
	newList add: elemB.  newList add: elemA.
	^ newList]
with: elemA with: elemB with: elemC	| newList | [
	newList <- self new.
	newList add: elemC.  newList add: elemB.  newList add: elemA.
	^ newList]
]

Dictionary [

noKey [
	self error: 'key not found in dictionary lookup']
at: key [
	^ self at: key ifAbsent: [ self noKey ]]
at: key put: value | position | [
	position <- keys location: key.
	(position <= keys size and: [ key = (keys at: position)])
		ifTrue: [ values at: position put: value ]
		ifFalse: [ keys <- keys insert: key at: position.
			values <- values insert: value at: position ].
	^ value]
at: key ifAbsent: exceptionBlock | position | [
	position <- keys location: key.
	((position <= keys size) and: [ key = (keys at: position)])
		ifTrue: [ ^ values at: position ]
		ifFalse: [ ^ exceptionBlock value ]]
binaryDo: aBlock [
	1 to: keys size do:
		[:i | aBlock value: (keys at: i) value: (values at: i) ]]
keysDo: aBlock [
	1 to: keys size do: [:i| aBlock value: (keys at: i)]]
keysAsArray | i ret | [
	ret <- Array new: keys size.
	1 to: keys size do: [:i| ret at: i put: (keys at: i)].
	^ ret]
isEmpty [
	^ keys isEmpty]
do: aBlock [
	values do: aBlock]
removeKey: key ifAbsent: exceptionBlock | position | [
	position <- keys location: key.
	(position <= keys size and: [ key = (keys at: position) ])
		ifTrue: [ keys <- keys removeIndex: position.
			values <- values removeIndex: position]
		ifFalse: [ ^ exceptionBlock value ]]
removeKey: key [
	^ self removeKey: key ifAbsent: [ self noKey ]]
printString | count res | [
	res <- self class printString + ' ('.
	count <- 0.
	self binaryDo: [:k :elem|
		(count = 0) ifFalse: [ res <- res + ', ' ].
		res <- res + (k printString + ' -> ' + elem printString).
		count <- count + 1.
		(count >= 20) ifTrue: [ ^ res + ', ...)' ]
	].
	^ res + ')']
add: anAssoc [
	self at: anAssoc key put: anAssoc value]
]

MetaDictionary [

new | newDict | [
	newDict <- super new.
	self in: newDict at: 1 put: (OrderedArray new: 0).
	self in: newDict at: 2 put: (Array new: 0).
	^ newDict]
]

Array [

badIndex [
	self error: 'array indexing error']
at: index [
	<24 self index>
	(self includesKey: index) ifFalse: [ self badIndex ].
	self primitiveFailed]
at: index ifAbsent: exceptionBlock [
	<24 self index>
	exceptionBlock value]
includes: aValue [
	self do: [ :element | element = aValue ifTrue: [ ^ true ]].
	^ false]
indexOf: aValue [
	1 to: self size do: [:idx|
		((self at: idx) == aValue) ifTrue: [ ^ idx ]
	].
	^ nil]
indexOfVal: aValue [
	1 to: self size do: [:idx|
		((self at: idx) = aValue) ifTrue: [ ^ idx ]
	].
	^ nil]
copy [
	^ self asArray]
with: newItem	| newArray size | [
	size <- self size.
	newArray <- self class new: size + 1.
	newArray replaceFrom: 1 to: size with: self.
	newArray at: size + 1 put: newItem.
	^ newArray]
+ aValue	| size1 size2 newValue | [
	" catenate two strings together "
	size1 <- self size.
	size2 <- aValue size.
	newValue <- self class new: (size1 + size2).
	newValue replaceFrom: 1 to: size1 with: self.
	newValue replaceFrom: size1+1 to: size1+size2 with: aValue.
	^ newValue]
size [
	" compute number of elements "
	<4 self>]
at: index put: value [
	<5 value self index>
	(self includesKey: index) ifFalse: [ self badIndex ].
	self primitiveFailed]
do: aBlock [
	1 to: self size do: [:i | aBlock value: (self at: i)]]
reverseDo: aBlock [
	| i |
	i <- self size.
	[ i >= 1 ] whileTrue: [
		aBlock value: (self at: i).
		i <- i - 1
	]]
< arg		| selfsize argsize | [
	selfsize <- self size. argsize <- arg size.
	1 to: (selfsize min: argsize)
		do: [:i | (self at: i) ~= (arg at: i)
			ifTrue: [ ^ (self at: i) < (arg at: i) ]].
	^ selfsize < argsize]
= anArray [
	self size = anArray size ifFalse: [ ^ false ].
	1 to: self size do:
		[:i | (self at: i) = (anArray at: i)
			ifFalse: [ ^ false ]].
	^ true]
includesKey: index [
	^ index between: 1 and: self size]
insert: value at: position | newArray newSize | [
	newSize <- self size + 1.
	newArray <- self class new: newSize.
	newArray replaceFrom: 1 to: position-1 with: self.
	newArray at: position put: value.
	newArray replaceFrom: position+1 to: newSize with:
		self startingAt: position.
	^ newArray]
removeIndex: position  | newArray newSize | [
	newSize <- self size - 1.
	newArray <- self class new: newSize.
	newArray replaceFrom: 1 to: position-1 with: self.
	newArray replaceFrom: position to: newSize with: self
		startingAt: position+1.
	^ newArray]
first [
	^self at: 1]
from: low to: high | start stop size obj | [
	start <- low max: 0.
	stop <- high min: self size.
	size <- (stop + 1 - start) max: 0.
	obj <- (self species) new: size.
	1 to: size do: [ :i |
		obj at: i put: (self at: start).
		start <- start + 1 ].
	^ obj]
hash | sz | [
	sz <- self size.
	(sz < 2) ifTrue: [
		(sz = 1) ifTrue: [ ^ (self at: 1) hash + sz ].
		^ 0
	].
	^ (self at: 1) hash + (self at: sz) hash]
elementsExchangeIdentityWith: otherArray [
	<35 self otherArray>.
	self primitiveFailed]
replaceFrom: start to: stop with: replacement [
	^ self replaceFrom: start to: stop with: replacement startingAt: 1]
replaceFrom: start to: stop with: replacement startingAt: repStart | base | [
	<38 start stop replacement repStart self>.
	base <- repStart-1.
	0 to: (stop - start) do: [:idx|
		self at: (idx + start) put:
			(replacement at: (idx + repStart))
	]]
]

MetaArray [

new [
	^ self new: 0]
new: sz [
	<7 self sz>]
with: elemA | ret | [
	ret <- self new: 1.
	ret at: 1 put: elemA.
	^ ret]
with: elemA with: elemB | ret | [
	ret <- self new: 2.
	ret at: 1 put: elemA.
	ret at: 2 put: elemB.
	^ ret]
with: elemA with: elemB with: elemC | ret | [
	ret <- self new: 3.
	ret at: 1 put: elemA.
	ret at: 2 put: elemB.
	ret at: 3 put: elemC.
	^ ret]
]

OrderedArray [

add: value [
	^ self insert: value at: (self location: value)]
includes: value | position | [
	position <- self location: value.
	^ (position <= self size) and: [ value = (self at: position)]]
location: value | low high mid | [
	low <- 1.
	high <- self size + 1.
	[ low < high ] whileTrue:
		[ mid <- (low + high) quo: 2.
		(self at: mid) < value
			ifTrue: [ low <- mid + 1 ]
			ifFalse: [ high <- mid ] ].
	^ low]
]

MetaOrderedArray [

]

ByteArray [

basicAt: index [
	<21 self index>
	^nil]
at: index [
	<21 self index>
	(self includesKey: index) ifFalse: [ self badIndex ].
	self primitiveFailed]
at: index ifAbsent: exceptionBlock [
	<21 self index>
	exceptionBlock value]
at: index put: aValue [
	<22 aValue self index>
	(self includesKey: index) ifFalse: [ self badIndex ].
	self primitiveFailed]
asString | str sz | [
	sz <- self size.
	str <- String new: sz.
	1 to: sz do: [:i| str at: i put: ((self at: i) asChar)].
	^ str]
]

MetaByteArray [

new: size [
	<20 self size>]
]

MetaString [

new: size [
	<20 self size>]
input	| value c nl | [
	" read a line from input "
	value <- ''. nl <- Char newline.
	[ c <- Char input.
	  c isNil ifTrue: [ ^ nil ]. c ~= nl ] whileTrue:
		[ value <- value + c asString ].
	^ value]
newline [
	^ Char newline asString]
tab [
	^ Char tab asString]
]

MetaMetaString [

]

String [

edit [
	<105 self>]
break: separators  | words word | [
	" break string into words, using separators "
	word <- ''.
	words <- List new.
	self do: [:c |
		(separators includes: c)
			ifTrue: [
				(word size > 0) " found a word "
					ifTrue: [ words addLast: word.
							word <- '' ] ]
			ifFalse: [ word <- word + c asString ] ].
		" maybe a last word "
	(word size > 0) ifTrue: [ words addLast: word ].
	^ words]
collect: transformationBlock [
	^ (super collect: transformationBlock) asString]
reverse [
	^ self asList reverse asString]
select: testBlock [
	^ (super select: testBlock) asString]
printString [
	^ self]
printWidth: width | ret | [
	(self size >= width absolute) ifTrue: [ ^ self ].
	ret <- self.
	(width negative) ifTrue: [
			(self size + 1) to: (width negated) do:
				[:ignore| ret <- ' ' + ret].
		]
		ifFalse: [
			(self size + 1) to: width do:
				[:ignore| ret <- ret + ' ' ].
		].
	^ret]
asSymbol [
	^ Symbol new: self]
doIt	| meth | [
	meth <- Undefined parseMethod: 'doItCommand ^' + self.
	^ meth notNil
		ifTrue: [ ^ Context new
			  perform: meth withArguments: (Array new: 1) ]]
basicAt: index [
	<21 self index>
	^nil]
at: index [
	^self at: index ifAbsent: [ self badIndex ]]
at: index ifAbsent: exceptionBlock | c | [
	c <- self basicAt: index.
	(c isNil)
	     ifTrue: [ ^ exceptionBlock value ]
	     ifFalse: [ ^ Char new: c ]]
basicAt: index put: value [
	<22 value self index>
	^nil]
at: index put: aValue [
	(self basicAt: index put: aValue value) isNil ifTrue: [
		self badIndex
	]]
copy [
	" make a clone of ourself "
	<23 self String>]
asNumber | val | [
	" parse a base-10 ASCII number, return nil on failure "
	val <- 0.
	self do: [:c|
		c isDigit ifFalse: [^nil].
		val <- (val * 10) + (c value - 48)
	].
	^val]
hash | sz | [
	sz <- self size.
	(sz < 2) ifTrue: [
		(sz = 1) ifTrue: [ ^ (self at: 1) value ].
		^ 0
	].
	^ (self at: 1) value + (self at: sz) value]
lowerCase | ret c | [
	ret <- String new: (self size).
	1 to: self size do: [:x|
		c <- self at: x.
		c isUpperCase ifTrue: [c <- c lowerCase].
		ret at: x put: c
	].
	^ ret]
indexOf: val | c s | [
	" For non-strings, search scalar Array elements "
	(val isKindOf: String) ifFalse: [ ^ super indexOf: val ].]
]

Set [

size | tally | [
	tally <- 0.
	members do: [:elem| elem notNil ifTrue: [ tally <- tally + 1 ] ].
	^ tally]
grow | bigger old oldsize | [
	" Re-create ourselves in place with a new, bigger storage "
	old <- members.
	members <- Array new: (old size + growth).]
compare: t and: e [
	^ t = e]
location: elem | pos start t | [
	start <- pos <- (elem hash rem: members size) + 1.
	[ true ] whileTrue: [
		" Return this position if we match, or have reached
		  a nil slot. "
		t <- members at: pos.
		((t isNil) or: [self compare: t and: elem]) ifTrue: [
			^ pos
		].]]
add: elem | pos | [
	" Find the appropriate slot... if none, need to grow the Set "
	pos <- self location: elem.
	pos isNil ifTrue: [
		self grow.
		^ self add: elem
	].]
rehash: start | pos elem | [
	pos <- start.
	[ true ] whileTrue: [
		" Advance to next slot, ceasing when we reach our start "
		pos <- pos + 1.
		(pos > members size) ifTrue: [ pos <- 1 ].
		(pos = start) ifTrue: [ ^ self ]]]
remove: elem ifAbsent: aBlock | pos | [
	" If not found, return error "
	pos <- self location: elem.
	((pos isNil) or: [(members at: pos) isNil]) ifTrue: [
		aBlock value
	].]
remove: elem [
	^ self remove: elem ifAbsent: [self noElement ]]
do: aBlock [
	members do: [:elem| elem notNil ifTrue: [ aBlock value: elem ]]]
at: value ifAbsent: aBlock | pos | [
	pos <- self location: value.
	((pos isNil) or: [ (members at: pos) isNil ]) ifTrue: [
		^ aBlock value
	].
	^ value]
indexOf: value [
	^ self at: value ifAbsent: [ nil ]]
]

MetaSet [

new: size | ret | [
	ret <- super new.
	self in: ret at: 1 put: (Array new: size).
	self in: ret at: 2 put: size.
	^ ret]
with: objA | ret | [
	ret <- self new.
	ret add: objA.
	^ ret]
with: objA with: objB | ret | [
	ret <- self new.
	ret add: objA. ret add: objB.
	^ ret]
with: objA with: objB with: objC | ret | [
	ret <- self new.
	ret add: objA. ret add: objB. ret add: objC.
	^ ret]
new [
	^ self new: 10]
]

IdentitySet [

compare: t and: e [
	^ t == e]
]

MetaIdentitySet [

]

Number [

negative [
	^self < 0]
absolute [
	(self negative) ifTrue: [ ^ self negated ]]
negated [
	^0-self]
factorial [
	self <= 1 ifTrue: [ ^ 1 ]
	ifFalse: [ ^ (self - 1) factorial * self ]]
asDigit [
	(self < 10) ifTrue:
		[ ^(Char new: (self asSmallInt + 48)) asString ].
	^(Char new: (self asSmallInt + 55)) asString]
printWidth: width base: base | res n dig wasNeg wide | [
	res <- ''.
	(self negative) ifTrue: [
		wasNeg <- true.
		wide <- width-1.
		n <- self negated
	] ifFalse: [
		wasNeg <- false.
		wide <- width.
		n <- self
	].
	[true] whileTrue: [
		res <- ((n rem: base) asDigit) + res.
		n <- n quo: base.
		(n = 0) ifTrue: [
			((res size)+1) to: wide do: [:ignore|
				res <- '0' + res
			].
			wasNeg ifTrue: [ res <- '-' + res ].
			^res
		]
	]]
printWidth: width [
	^self printWidth: width base: 10]
printString [
	^self printWidth: 1 base: 10]
to: limit [
	^ Interval from: self to: limit step: 1]
to: limit by: step [
	^ Interval from: self to: limit step: step]
to: limit do: aBlock  | i | [
		" optimize arithmetic loops "
	i <- self.
	[ i <= limit ] whileTrue: [ aBlock value: i. i <- i + 1 ]]
to: limit by: step do: aBlock  | i | [
	i <- self.
	[ i <= limit ] whileTrue: [ aBlock value: i. i <- i + step ]]
overflow [
	self error: 'Numeric overflow']
bitAnd: arg [
	^ (self asSmallInt bitAnd: arg)]
bitOr: arg [
	^ (self asSmallInt bitOr: arg)]
bitShift: arg [
	^ (self asSmallInt bitShift: arg)]
atRandom [
	" Return random number from 1 to self "
	(self < 2) ifTrue: [ ^ self ].
	^ ((1 to: self) atRandom)]
asChar [
	^ Char new: (self asSmallInt)]
]

MetaNumber [

new [
	" can't create this way, return zero "
	^ 0]
]

Integer [

asInteger [
	^self]
asSmallInt [
	<33 self>.
	self overflow]
truncSmallInt [
	<40 self>.
	self primitiveFailed]
hash [
	<33 self>.
	^ (self rem: 65536) asSmallInt]
quo: arg [
	<25 self arg>
	(arg isMemberOf: Integer) ifFalse: [^self quo: arg asInteger].
	(0 = arg) ifTrue: [^ self error: 'division by zero'].
	self primitiveFailed]
rem: arg [
	<26 self arg>
	(arg isMemberOf: Integer) ifFalse: [^self rem: arg asInteger].
	(0 = arg) ifTrue: [^ self error: 'division by zero'].
	self primitiveFailed]
+ arg [
	<27 self arg>
	(arg isMemberOf: Integer) ifFalse: [^self + arg asInteger].
	self primitiveFailed]
* arg [
	<28 self arg>
	(arg isMemberOf: Integer) ifFalse: [^self * arg asInteger].
	self primitiveFailed]
- arg [
	<29 self arg>
	(arg isMemberOf: Integer) ifFalse: [^self - arg asInteger].
	self primitiveFailed]
< arg [
	<30 self arg>
	(arg isMemberOf: Integer) ifFalse: [^self < arg asInteger].
	self primitiveFailed]
= arg [
	<31 self arg>
	(arg isMemberOf: Integer) ifFalse: [^self = arg asInteger].
	self primitiveFailed]
]

MetaInteger [

new: low [
	<32 low>
	low <- low asSmallInt.
	<32 low>
	self primitiveFailed]
]

SmallInt [

asSmallInt [
	^self]
truncSmallInt [
	^self]
asInteger [
	^Integer new: self]
quo: arg [
	<11 self arg>
	(arg isMemberOf: SmallInt) ifFalse: [^self quo: arg asSmallInt].
	(0 = arg) ifTrue: [^ self error: 'division by zero'].
	self primitiveFailed]
rem: arg [
	<12 self arg>
	(arg isMemberOf: SmallInt) ifFalse: [^self rem: arg asSmallInt].
	(0 = arg) ifTrue: [^ self error: 'division by zero'].
	self primitiveFailed]
+ arg [
	<10 self arg>
	(arg isMemberOf: SmallInt) ifFalse: [^self + arg asSmallInt].
	self primitiveFailed]
* arg [
	<15 self arg>
	(arg isMemberOf: SmallInt) ifFalse: [^self * arg asSmallInt].
	self primitiveFailed]
- arg [
	<16 self arg>
	(arg isMemberOf: SmallInt) ifFalse: [^self - arg asSmallInt].
	self primitiveFailed]
< arg [
	<13 self arg>
	(arg isMemberOf: SmallInt) ifFalse: [^self < arg asSmallInt].
	self primitiveFailed]
= arg [
	<14 self arg>
	(arg isMemberOf: SmallInt) ifFalse: [^self = arg asSmallInt].
	self primitiveFailed]
hash [
	^ self]
bitOr: arg [
	<36 self arg>.
	^ (self bitOr: arg asSmallInt)]
bitAnd: arg [
	<37 self arg>.
	^ (self bitAnd: arg asSmallInt)]
bitShift: arg [
	<39 self arg>.
	(arg isKindOf: SmallInt) ifTrue: [ self overflow ].
	^ (self bitShift: arg asSmallInt)]
]

MetaSmallInt [

atRandom [
	" Set up seed one time.  TBD: init from something external;
	  getpid() or time() "
	seed isNil ifTrue: [ seed <- 17 ].]
]

Link [

value [
	^ value]
value: val [
	value <- val]
next [
	^ next]
do: aBlock [
	aBlock value: value.
	next notNil ifTrue: [ ^ next do: aBlock ]]
remove: anElement ifAbsent: exceptionBlock [
	value = anElement
		ifTrue: [ ^ next ]
		ifFalse: [ next notNil
			ifTrue: [ next <- next remove: anElement
				ifAbsent: exceptionBlock. ^ self ]
			ifFalse: [ ^ exceptionBlock value ] ]]
reverseDo: aBlock [
	next notNil ifTrue: [ next reverseDo: aBlock ].
	aBlock value: value]
addLast: anElement [
	next notNil
		ifTrue: [ ^ next addLast: anElement ]
		ifFalse: [ next <- Link value: anElement ]]
]

MetaLink [

value: v [
		" return a new link with given value field "
		" and empty link field "
	^ self in: self new at: 1 put: v]
value: v next: n	| new | [
		" return a new link with the given fields "
	new <- self new.
	self in: new at: 1 put: v.
	self in: new at: 2 put: n.
	^ new]
]

Node [

do: aBlock [
	left notNil ifTrue: [ left do: aBlock ].
	aBlock value: value.
	^ right notNil ifTrue: [ right do: aBlock ]]
reverseDo: aBlock [
	right notNil ifTrue: [ right do: aBlock ].
	aBlock value: value.
	left notNil ifTrue: [ left do: aBlock ]]
first [
	left notNil
		ifTrue: [ ^ left first ]
		ifFalse: [ ^ value ]]
removeFirst [
	left notNil
		ifTrue: [ left <- left removeFirst. ^ self ]
		ifFalse: [ ^ right ]]
add: anElement [
	value < anElement
		ifTrue: [ right notNil
			ifTrue: [ right add: anElement ]
			ifFalse: [ right <- Node new: anElement ] ]
		ifFalse: [ left notNil
			ifTrue: [ left add: anElement ]
			ifFalse: [ left <- Node new: anElement ] ]]
remove: key ifAbsent: exceptionBlock [
	value = key
		ifTrue: [ right notNil
			ifTrue: [ value <- right first.
			right <- right removeFirst.
			^ self ]
			ifFalse: [ ^ left ] ].
	value < key
		ifTrue: [ right notNil
			ifTrue: [ right <- right remove: key ifAbsent: exceptionBlock ]
			ifFalse: [ ^ exceptionBlock value ] ]
		ifFalse: [ left notNil
			ifTrue: [ left <- left removeL key ifAbsent: exceptionBlock ]
			ifFalse: [ ^ exceptionBlock value ] ]]
value [
	^ value]
at: key ifAbsent: exceptionBlock [
	value = key ifTrue: [ ^ value ].
	value < key
		ifTrue: [ right notNil
			ifTrue: [ ^ right at: key ifAbsent: exceptionBlock ]
			ifFalse: [ ^ exceptionBlock value ] ]
		ifFalse: [ left notNil
			ifTrue: [ ^ left at: key ifAbsent: exceptionBlock ]
			ifFalse: [ ^ exceptionBlock value ] ]]
]

MetaNode [

new: value [
	" creation, left left and right empty "
	^ self in: self new at: 1 put: value]
]

Interval [

do: aBlock	| current | [
	current <- low.
	(step < 0)
		ifTrue: [
			[ current >= high ] whileTrue:
				[ aBlock value: current.
				current <- current + step ] ]
		ifFalse: [
			[ current <= high ] whileTrue:
				[ aBlock value: current.
				current <- current + step ] ]]
low: l [
	low <- l]
high: h [
	high <- h]
low [
	^ low]
high [
	^ high]
includes: val [
	" Check within range first "
	((val < low) or: [val > high]) ifTrue: [ ^ false ].
	" Then check if in equivalence class of interval "
	^ ((val - low) rem: step) = 0]
printString | s | [
	s <- (self class printString) + ' <' +
		low printString + '..' + high printString.
	(step ~= 1) ifTrue: [ s <- s + ' by ' + step printString ].
	^ s + '>']
atRandom | ret | [
	" Return a random element from our sequence "
	ret <- (SmallInt atRandom) rem: ((high - low + 1) quo: step).
	^ low + (ret * step)]
]

MetaInterval [

from: l to: h step: s | newInterval | [
	newInterval <- self in: self new at: 1 put: l.
	self in: newInterval at: 2 put: h.
	self in: newInterval at: 3 put: s.
	^ newInterval]
]

File [

opened [
	^ fileID notNil]
close: id [
	<103 id>]
close [
		" close file, return file descriptor "
	fileID notNil ifTrue: [
		self close: fileID.
		fileID <- nil
	]]
writeImage [
		" save the current image in a file "
	fileID notNil
		ifTrue: [ <104 fileID> ]]
notOpened [
	self error: 'file is not open']
writeCharValue: n [
	<102 fileID n>.
	fileID isNil ifTrue: [ self notOpened ].
	self primitiveFailed]
doRead [
	<101 fileID>.
	fileID isNil ifTrue: [ self notOpened ].
	self primitiveFailed]
readChar	| c | [
		" read a single character from a file "
	c <- self doRead.
	c notNil ifTrue: [ ^ Char new: c ].
	^ c]
readLine	| value  c nl | [
	" read a line from input "
	fileID isNil ifTrue: [ self error: 'cannot read from unopened file' ].
	value <- ''.
	nl <- Char newline.
	[ c <- self doRead.
	  c isNil ifTrue: [ ^ nil ].
	  c <- Char new: c.
	  c ~= nl ] whileTrue:
		[ value <- value + c asString ].
	^ value]
fileInDispatch: cmd | c | [
	" Immediate execte "
	cmd = $+ ifTrue: [
		self readLine doIt printNl.
		^ self
	].]
fileIn		| cmd | [
	[ cmd <- self readChar. cmd notNil ] whileTrue: [
		self fileInDispatch: cmd
	]]
methodCommand: classCmd | name aClass text line | [
	name <- self readLine asSymbol.
	aClass <- globals at: name ifAbsent: [ ^ self error:
		'unknown class name in file-in: ' + name printString ].
	text <- ''.
	[ line <- self readLine.
	  line isNil ifTrue: [ ^ self error:
		'unexpected end of input during fileIn' ].
	  line ~= '!'] whileTrue: [ text <- text + line + String newline ].
	classCmd
		ifTrue: [ aClass addMethod: text ]
		ifFalse: [ aClass class addMethod: text ]]
at: idx [
	<108 fileID idx>.
	self primitiveFailed]
write: buf size: count [
	<107 fileID buf count>.
	self primitiveFailed]
write: buf [
	^ self write: buf size: (buf size)]
at: idx put: buf [
	self at: idx.
	self write: buf size: buf size]
at: idx get: buf | size | [
	self at: idx.
	size <- buf size.
	<106 fileID buf size>]
at: idx size: count | buf res | [
	buf <- ByteArray new: count.
	res <- self at: idx get: buf.
	(res < count) ifTrue: [ buf <- buf from: 1 to: res ].
	^ buf]
newline [
	^ self write: (String newline)]
]

MetaFile [

doOpen: nm mode: mode [
	<100 nm mode>]
openRead: nm [
		" open new file for reading "
	^ self in: (self new) at: 1 put: (self doOpen: nm mode: 'r')]
openWrite: nm [
		" open new file for writing "
	^ self in: (self new) at: 1 put: (self doOpen: nm mode: 'w')]
openUpdate: nm [
		" open new file for reading and writing "
	^ self in: (self new) at: 1 put: (self doOpen: nm mode: 'r+')]
fileIn: nm | file | [
	file <- self openRead: nm.
	file opened ifFalse: [ ^ self error: 'cannot open file ' + nm ].
	file fileIn.
	file close.
	^ 'file in completed']
image: nm | file | [
		" open a file, write the image, then close "
	file <- self openWrite: nm.
	file opened ifFalse: [ ^ self error: 'cannot open file ' + nm ].
	file writeImage.
	file close]
]

Association [

= k [
		"compare both with keys and associations"
	(k class == Association)
		ifTrue: [ ^ key = k key ]
		ifFalse: [ ^ key = k ]]
< k [
		"compare both with keys and associations"
	(k class == Association)
		ifTrue: [ ^ key < k key ]
		ifFalse: [ ^ key < k ]]
value: v [
	value <- v]
value [
	^ value]
key [
	^ key]
hash [
	^ key hash]
printString [
	^ '(' + key printString + ' -> ' + value printString + ')']
]

MetaAssociation [

key: k [
		"key is set once, value is resettable"
	^ self in: self new at: 1 put: k]
key: k value: v | ret | [
		"key is set once, value is resettable"
	ret <- self new.
	self in: ret at: 1 put: k.
	self in: ret at: 2 put: v.
	^ ret]
]

Tree [

add: anElement [
	root isNil
		ifTrue: [ root <- Node new: anElement ]
		ifFalse: [ root add: anElement ].
	^anElement]
addAll: aCollection [
	aCollection do: [:element| self add: element ]]
at: key ifAbsent: exceptionBlock [
	root isNil
		ifTrue: [ ^ exceptionBlock value ]
		ifFalse: [ ^ root at: key ifAbsent: exceptionBlock ]]
copy [
	^Tree new addAll: self]
collect: transformBlock | newTree | [
	newTree <- Tree new.
	self do: [:element| newTree add: (transformBlock value: element)].
	^newTree]
do: aBlock [
	root notNil ifTrue: [ root do: aBlock ]]
select: testBlock | newTree | [
	newTree <- Tree new.
	self do: [:element|
		(testBlock value: element)
			ifTrue: [newTree add: element]
	].
	^newTree]
reverseDo: aBlock [
	root notNil ifTrue: [ root reverseDo: aBlock ]]
removeFirst [
	root isNIl ifTrue: [ self emptyCollection ].
	root <- root removeFirst]
remove: key ifAbsent: exceptionBlock [
	root isNil
		ifTrue: [ exceptionBlock value ]
		ifFalse: [ root <- root remove: key ifAbsent: exceptionBlock ]]
first [
	root notNil
		ifTrue: [ ^root first ]
		ifFalse: [ self emptyCollection ]]
isEmpty [
	^ root isNil]
]

MetaTree [

]

Parser [

text: aString instanceVars: anArray [
	text <- aString.
	index <- 1.
	lineNum <- 1.
	argNames <- Array new: 1.
	argNames at: 1 put: #self.
	instNames <- anArray.
	tempNames <- Array new: 0.
	maxTemps <- 0]
parse: c with: encoderClass	| encoder meth name | [
	" note -- must call text:instanceVars: first "
	errBlock <- [ ^ nil ].
	self nextLex.
	encoder <- encoderClass new.
	name <- self readMethodName.
	(c ~= Undefined) ifTrue: [
		'Compiling ' print. c print. ':' print.
		name print. '... ' print
	].
	encoder name: name.
	self readMethodVariables.
	self readBody compile: encoder block: false.
	meth <- encoder method: maxTemps class: c text: text.
	meth args: argNames inst: instNames temp: tempNames.
	^ meth]
parse: c [
	^ self parse: c with: Encoder]
error: aString [
	'Compile error near line ' print.
	lineNum printString print.
	': ' print.
	aString printNl.
	errBlock value]
currentChar [
	^ text at: index ifAbsent: [ Char eof ]]
nextChar [
	(self currentChar = Char newline) ifTrue: [
		lineNum <- lineNum + 1
	].
	index <- index + 1.
	^ self currentChar]
nextLex [
	self skipBlanks.
	tokenType <- self currentChar.
	tokenType isEOF   " end of input "
		ifTrue: [ tokenType <- $  . token <- nil. ^ nil ].
	tokenType isDigit ifTrue: [ ^ self lexInteger ].
	tokenType isAlphabetic ifTrue: [ ^ self lexAlnum ].
	^ self lexBinary]
skipBlanks  | cc | [
	cc <- self currentChar.
	[ cc isBlank ] whileTrue: [ cc <- self nextChar ].
	( cc = $" ) ifTrue: [ self skipComment ]]
skipComment  | cc | [
	[ cc <- self nextChar.
	  cc isEOF ifTrue: [ ^ self error: 'unterminated comment'].
	  cc ~= $" ] whileTrue: [ nil ].
	self nextChar. self skipBlanks]
lexInteger	| start | [
	start <- index.
	[ self nextChar isDigit ]
		whileTrue: [ nil ].
	token <- text from: start to: index - 1]
lexAlnum | cc start | [
	start <- index.
	[ ((cc <- self nextChar) isAlphanumeric) or: [ cc = $: ] ]
			whileTrue: [ nil ].
		" add any trailing colons "
	token <- text from: start to: index - 1]
lexBinary	| c d | [
	c <- self currentChar.
	token <- c asString.
	d <- self nextChar.
	(self charIsSyntax: c) ifTrue: [ ^ token ].
	(((d isBlank
		or: [ d isDigit])
		or: [ d isAlphabetic ])
		or: [ self charIsSyntax: d])
			ifTrue: [ ^ token ].
	token <- token + d asString.
	self nextChar]
charIsSyntax: c [
	^ ('.()[]#^$;' includes: c) or: [ c = $' ]]
readMethodName   | name | [
	self tokenIsName	" unary method "
		ifTrue: [ name <- token. self nextLex. ^ name ].
	self tokenIsBinary	" binary method "
		ifTrue: [ name <- token. self nextLex.
			self tokenIsName
				ifFalse: [ self error: 'missing argument'].
				self addArgName: token asSymbol.
				self nextLex. ^ name ].
	self tokenIsKeyword
		ifFalse: [ self error: 'invalid method header'].
	name <- ''.
	[ self tokenIsKeyword ]
		whileTrue: [ name <- name + token. self nextLex.
			self tokenIsName
				ifFalse: [ self error: 'missing argument'].
				self addArgName: token asSymbol.
				self nextLex ].
	^ name]
addArgName: name [
	((instNames includes: name)
		or: [ argNames includes: name ])
		ifTrue: [ self error: 'doubly defined argument name: ' +
			name asString].
	argNames <- argNames with: name]
tokenIsName [
	tokenType isAlphabetic ifFalse: [ ^ false ].
	^ (token at: token size) isAlphanumeric]
tokenIsKeyword [
	tokenType isAlphabetic ifFalse: [ ^ false ].
	^ (token at: token size) = $:]
tokenIsBinary [
	(((token isNil
		or: [ self tokenIsName])
		or: [ self tokenIsKeyword])
		or: [ self charIsSyntax: tokenType ]) ifTrue: [ ^ false ].
	^ true]
readMethodVariables [
	tokenType = $| ifFalse: [ ^ nil ].
	self nextLex.
	[ self tokenIsName ]
		whileTrue: [ self addTempName: token asSymbol. self nextLex ].
	tokenType = $|
		ifTrue: [ self nextLex ]
		ifFalse: [ self error: 'illegal method variable declaration']]
addTempName: name [
	(((argNames includes: name)
		or: [ instNames includes: name ] )
		or: [ tempNames includes: name ] )
		ifTrue: [ self error: 'doubly defined name '].
	tempNames <- tempNames with: name.
	maxTemps <- maxTemps max: tempNames size]
readBody | lnum | [
	lnum <- lineNum.
	^ (BodyNode at: lnum) statements: self readStatementList]
readStatementList   | list | [
	list <- List new.
	[ list add: self readStatement.
	  tokenType notNil and: [ tokenType = $. ] ]
		whileTrue: [ self nextLex.
			(token isNil or: [ tokenType = $] ] )
				ifTrue: [ ^ list ] ].
	^ list]
readStatement | lnum | [
	tokenType = $^
		ifTrue: [ lnum <- lineNum. self nextLex.
			^ (ReturnNode at: lnum)
				expression: self readExpression ].
	^ self readExpression]
readExpression   | node lnum | [
	self tokenIsName ifFalse: [ ^ self readCascade: self readTerm ].
	node <- self nameNode: token asSymbol. self nextLex.
	self tokenIsArrow
		ifTrue: [ node assignable
				ifFalse: [ self error: 'illegal assignment'].
			lnum <- lineNum.
			self nextLex.
			^ (AssignNode at: lnum) target:
				node expression: self readExpression ].
	^ self readCascade: node]
tokenIsArrow [
	(token isKindOf: String) ifFalse: [ ^ false ].
	^ token = '<-']
readTerm   | node lnum | [
	token isNil
		ifTrue: [ self error: 'unexpected end of input' ].
	tokenType = $(
		ifTrue: [ self nextLex. node <- self readExpression.
			tokenType = $)
				ifFalse: [ self error: 'unbalanced parenthesis' ].
			self nextLex. ^ node ].
	tokenType = $[ ifTrue: [ ^ self readBlock ].
	tokenType = $< ifTrue: [ ^ self readPrimitive ].
	self tokenIsName
		ifTrue: [ node <- self nameNode: token asSymbol.
			self nextLex. ^ node ].
	lnum <- lineNum.
	^ (LiteralNode at: lnum) value: self readLiteral]
nameNode: name [
	" make a new name node "
	name == #super
		ifTrue: [ ^ (ArgumentNode at: lineNum) position: 0 ].
	(1 to: tempNames size) do: [:i |
		(name == (tempNames at: i))
			ifTrue: [ ^ (TemporaryNode at: lineNum)
				position: i ] ].
	(1 to: argNames size) do: [:i |
		(name == (argNames at: i))
			ifTrue: [ ^ (ArgumentNode at: lineNum) position: i ] ].
	(1 to: instNames size) do: [:i |
		(name == (instNames at: i))
			ifTrue: [ ^ (InstNode at: lineNum) position: i ] ].
	^ (LiteralNode at: lineNum);
		value: (globals at: name
			ifAbsent: [ ^ self error:
				'unrecognized name: ' + name printString ])]
readLiteral   | node | [
	tokenType = $$
		ifTrue: [ node <- self currentChar.
			self nextChar. self nextLex. ^ node ].
	tokenType isDigit
		ifTrue: [ ^ self readInteger ].
	token = '-'
		ifTrue: [ self nextLex. ^ self readInteger negated ].
	tokenType = $'
		ifTrue: [ ^ self readString ].
	tokenType = $#
		ifTrue: [ ^ self readSymbol ].
	self error: 'invalid literal: ' + token]
readInteger  | value | [
	value <- token asNumber.
	value isNil ifTrue: [ self error: 'integer expected' ].
	self nextLex.
	^ value]
readString  | first last cc | [
	first <- index.
	[ cc <- self currentChar.
	  cc isNil ifTrue: [ self error: 'unterminated string constant'].
	  cc ~= $' ] whileTrue: [ index <- index + 1 ].
	last <- index - 1.
	self nextChar = $'
		ifTrue: [ self nextChar.
			^ (text from: first to: index - 2) + self readString ].
	self nextLex.
	^ text from: first to: last]
readSymbol   | cc | [
	cc <- self currentChar.
	(cc isEOF or: [ cc isBlank])
		ifTrue: [ self error: 'invalid symbol'].
	cc = $( ifTrue: [ ^ self readArray ].
	(self charIsSyntax: cc)
		ifTrue: [ self error: 'invalid symbol'].
	self nextLex.
	cc <- Symbol new: token. self nextLex.
	^ cc]
readArray	| value | [
	self nextChar. self nextLex. value <- Array new: 0.
	[ tokenType ~= $) ]
		whileTrue: [ value <- value with: self arrayLiteral ].
	self nextLex.
	^ value]
arrayLiteral	| node | [
	tokenType isAlphabetic
		ifTrue: [ node <- Symbol new: token. self nextLex. ^ node ].
	^ self readLiteral]
readPrimitive  | num args lnum | [
	lnum <- lineNum.
	self nextLex.
	num <- self readInteger.
	args <- List new.
	[ tokenType ~= $> ]
		whileTrue: [ args add: self readTerm ].
	self nextLex.
	^ (PrimitiveNode at: lnum) number: num arguments: args]
readBlock    | stmts saveTemps lnum | [
	saveTemps <- tempNames.
	lnum <- lineNum.
	self nextLex.
	tokenType = $:
		ifTrue: [ self readBlockTemporaries ].
	stmts <- self readStatementList.
	tempNames <- saveTemps.
	tokenType = $]
		ifTrue: [ self nextLex.
			^ (BlockNode at: lnum) statements: stmts
				temporaryLocation: saveTemps size ]
		ifFalse: [ self error: 'unterminated block']]
readBlockTemporaries [
	[ tokenType = $: ]
		whileTrue: [ self currentChar isAlphabetic
			ifFalse: [ self error: 'ill formed block argument'].
			self nextLex.
			self tokenIsName
				ifTrue: [ self addTempName: token asSymbol ]
				ifFalse: [ self error: 'invalid block argument list '].
			self nextLex ].
	tokenType = $|
		ifTrue: [ self nextLex ]
		ifFalse: [ self error: 'invalid block argument list ']]
readCascade: base   | node list | [
	node <- self keywordContinuation: base.
	tokenType = $;
		ifTrue: [ node <- (CascadeNode at: lineNum) head: node.
			list <- List new.
			[ tokenType = $; ]
				whileTrue: [ self nextLex.
					list add:
						(self keywordContinuation: nil ) ].
			node list: list ].
	^ node]
keywordContinuation: base  | receiver name args lnum | [
	receiver <- self binaryContinuation: base.
	self tokenIsKeyword
		ifFalse: [ ^ receiver ].
	name <- ''.
	args <- List new.
	lnum <- lineNum.
	[ self tokenIsKeyword ]
		whileTrue: [ name <- name + token. self nextLex.
			args add:
				(self binaryContinuation: self readTerm) ].
	^ (MessageNode at: lnum) receiver:
		receiver name: name asSymbol arguments: args]
binaryContinuation: base | receiver name lnum | [
	receiver <- self unaryContinuation: base.
	[ self tokenIsBinary]
		whileTrue: [ lnum <- lineNum.
			name <- token asSymbol. self nextLex.
			receiver <- (MessageNode at: lnum)
				receiver: receiver name: name arguments:
					(List with:
						(self unaryContinuation: self readTerm)) ].
	^ receiver]
unaryContinuation: base | receiver lnum | [
	receiver <- base.
	[ self tokenIsName ]
		whileTrue: [ lnum <- lineNum.
			receiver <- (MessageNode at: lnum)
				receiver: receiver name: token asSymbol
					arguments: (List new).
				self nextLex ].
	^ receiver]
]

MetaParser [

]

ParserNode [

isSuper [
	^ false]
isBlock [
	^ false]
assignable [
	^ false]
compile: encoder [
	encoder lineNum: lineNum]
]

MetaParserNode [

new [
	self error: 'Must use at: for creation']
at: l | ret | [
	ret <- super new.
	self in: ret at: 1 put: l.
	^ ret]
]

Encoder [

name: n [
	name <- n asSymbol.
	byteCodes <- ByteArray new: 20.
	index <- 0.
	literals <- Array new: 0.
	stackSize <- 0.
	maxStack <- 1.]
lineNum: l [
	" Don't care, except in DebugEncoder subclass "]
pushArgs: n [
	stackSize <- stackSize + n.
	maxStack <- stackSize max: maxStack]
popArgs: n [
	stackSize <- stackSize - n.]
genLiteral: aValue | idx | [
	idx <- literals indexOf: aValue.
	idx notNil ifTrue: [ ^ idx - 1 ].
	literals <- literals with: aValue.
	^ literals size - 1]
genHigh: high low: low [
	(low >= 16)
		ifTrue: [ self genHigh: 0 low: high. self genCode: low ]
		ifFalse: [ self genCode: high * 16 + low ]]
genCode: byte [
	index <- index + 1.
	(index >= byteCodes size)
		ifTrue: [ self expandByteCodes].
	byteCodes at: index put: byte.
	^ index]
genVal: byte [
	self genCode: (byte rem: 256).
	self genCode: (byte quo: 256).
	^ index-1]
expandByteCodes	| newarray size | [
	size <- byteCodes size.
	newarray <- ByteArray new: size + 8.
	1 to: size do: [:i | newarray at: i put: (byteCodes at: i)].
	byteCodes <- newarray]
patch: loc [
		" patch a goto from a block "
	byteCodes at: loc put: (index rem: 256).
	byteCodes at: (loc + 1) put: (index quo: 256)]
currentLocation [
	^ index]
backUp [
	" back up one instruction "
	index <- index - 1]
method: maxTemps class: c text: text [
	^ Method name: name byteCodes: byteCodes literals: literals
		stackSize: maxStack temporarySize: maxTemps class: c
		text: text]
]

MetaEncoder [

]

BodyNode [

statements: s [
	statements <- s]
compile: encoder block: inBlock [
	super compile: encoder.
	statements reverseDo:
		[ :stmt | stmt compile: encoder block: inBlock.
			encoder genHigh: 15 low: 5 " pop "].
	encoder genHigh: 15 low: 1 " return self "]
]

MetaBodyNode [

]

ReturnNode [

expression: e [
	expression <- e]
compile: encoder block: inBlock [
	super compile: encoder.
	expression compile: encoder block: inBlock.
	inBlock
		ifTrue: [ encoder genHigh: 15 low: 3 " block return " ]
		ifFalse: [ encoder genHigh: 15 low: 2 " stack return " ]]
]

MetaReturnNode [

]

AssignNode [

target: t expression: e [
	target <- t.
	expression <- e]
compile: encoder block: inBlock [
	super compile: encoder.
	expression compile: encoder block: inBlock.
	target assign: encoder]
]

MetaAssignNode [

]

LiteralNode [

value: v [
	value <- v]
compile: encoder block: inBlock [
	super compile: encoder.
	value == nil ifTrue: [ ^ encoder genHigh: 5 low: 10 ].
	value == true ifTrue: [ ^ encoder genHigh: 5 low: 11 ].
	value == false ifTrue: [ ^ encoder genHigh: 5 low: 12 ].
	(((value class == SmallInt) and:
	 [value < 10]) and: [value negative not])
		ifTrue: [ ^ encoder genHigh: 5 low: value ].
	encoder genHigh: 4 low: (encoder genLiteral: value)]
]

MetaLiteralNode [

]

ArgumentNode [

position: p [
	position <- p]
isSuper [
	^ position = 0]
compile: encoder block: inBlock [
	super compile: encoder.
	position = 0
		ifTrue: [ encoder genHigh: 2 low: 0 ]
		ifFalse: [ encoder genHigh: 2 low: position - 1 ]]
]

MetaArgumentNode [

]

TemporaryNode [

position: p [
	position <- p]
compile: encoder block: inBlock [
	super compile: encoder.
	encoder genHigh: 3 low: position - 1]
assignable [
	^ true]
assign: encoder [
	encoder genHigh: 7 low: position - 1]
]

MetaTemporaryNode [

]

InstNode [

position: p [
	position <- p]
compile: encoder block: inBlock [
	super compile: encoder.
	encoder genHigh: 1 low: position - 1]
assign: encoder [
	encoder genHigh: 6 low: position - 1]
assignable [
	^ true]
]

MetaInstNode [

]

PrimitiveNode [

number: n arguments: a [
	number <- n.
	arguments <- a.]
compile: encoder block: inBlock | argsize | [
	argsize <- arguments size.
	super compile: encoder.
	encoder pushArgs: argsize.
	arguments reverseDo: [ :a | a compile: encoder block: inBlock ].
	encoder genHigh: 13 low: argsize.
	encoder genCode: number.
	encoder popArgs: argsize]
]

MetaPrimitiveNode [

]

BlockNode [

statements: s temporaryLocation: t [
	statements <- s.
	temporaryLocation <- t]
compileInLine: encoder block: inBlock [
	statements reverseDo:
		[ :stmt | stmt compile: encoder block: inBlock.
			encoder genHigh: 15 low: 5 " pop top " ].
	encoder backUp]
isBlock [
	^ true]
compile: encoder block: inBlock | patchLocation | [
	super compile: encoder.
	encoder genHigh: 12 low: temporaryLocation.
	patchLocation <- encoder genVal: 0.
	self compileInLine: encoder block: true.
	encoder genHigh: 15 low: 2. " return top of stack "
	encoder patch: patchLocation]
]

MetaBlockNode [

]

CascadeNode [

head: h [
	head <- h]
list: l [
	list <- l]
compile: encoder block: inBlock [
	super compile: encoder.
	head compile: encoder block: inBlock.
	list reverseDo: [ :stmt |
		encoder genHigh: 15 low: 4. " duplicate "
		stmt compile: encoder block: inBlock.
		encoder genHigh: 15 low: 5 "pop from stack " ]]
]

MetaCascadeNode [

]

MessageNode [

receiver: r name: n arguments: a [
	receiver <- r.
	name <- n.
	arguments <- a]
compile: encoder block: inBlock [
	super compile: encoder.
	receiver isNil
		ifTrue: [ ^ self cascade: encoder block: inBlock ].
	((receiver isBlock and: [ self argumentsAreBlock ])
		and: [name = #whileTrue: or: [ name = #whileFalse ] ] )
		ifTrue: [ ^ self optimizeWhile: encoder block: inBlock ].
	receiver compile: encoder block: inBlock.
	receiver isSuper
		ifTrue: [ ^ self sendToSuper: encoder block: inBlock ].
	name = #isNil ifTrue: [ ^ encoder genHigh: 10 low: 0 ].
	name = #notNil ifTrue: [ ^ encoder genHigh: 10 low: 1 ].
	self compile2: encoder block: inBlock]
compile2: encoder block: inBlock [
	self argumentsAreBlock ifTrue: [
		name = #ifTrue: ifTrue: [ ^ self compile: encoder
				test: 8 constant: 10 block: inBlock ].
		name = #ifFalse: ifTrue: [ ^ self compile: encoder
				test: 7 constant: 10 block: inBlock ].
		name = #and: ifTrue: [ ^ self compile: encoder
				test: 8 constant: 12 block: inBlock ].
		name = #or: ifTrue: [ ^ self compile: encoder
				test: 7 constant: 11 block: inBlock ].
		name = #ifTrue:ifFalse:
			ifTrue: [ ^ self optimizeIf: encoder block: inBlock ].
		].
	self evaluateArguments: encoder block: inBlock.
	name = '<' asSymbol ifTrue: [ ^ encoder genHigh: 11 low: 0].
	name = '<=' asSymbol ifTrue: [ ^ encoder genHigh: 11 low: 1].
	name = '+' asSymbol ifTrue: [ ^ encoder genHigh: 11 low: 2].
	self sendMessage: encoder block: inBlock]
sendToSuper: encoder block: inBlock [
	self evaluateArguments: encoder block: inBlock.
	encoder genHigh: 8 low: 1 + arguments size.
	encoder genHigh: 15 low: 11.
	encoder genCode: (encoder genLiteral: name)]
cascade: encoder block: inBlock [
	self evaluateArguments: encoder block: inBlock.
	self sendMessage: encoder block: inBlock]
evaluateArguments: encoder block: inBlock [
	encoder pushArgs: 1 + arguments size.
	arguments reverseDo: [ :arg |
		arg compile: encoder block: inBlock ]]
sendMessage: encoder block: inBlock [
	encoder popArgs: arguments size.
		" mark arguments, then send message "
	encoder genHigh: 8 low: 1 + arguments size.
	encoder genHigh: 9 low: (encoder genLiteral: name)]
argumentsAreBlock [
	arguments do: [ :arg | arg isBlock ifFalse: [ ^ false ]].
	^ true]
optimizeWhile: encoder block: inBlock | start save | [
	start <- encoder currentLocation.
	receiver compileInLine: encoder block: inBlock.
	name = #whileTrue:	" branch if false/true "
		ifTrue: [ encoder genHigh: 15 low: 8 ]
		ifFalse: [ encoder genHigh: 15 low: 7 ].
	save <- encoder genVal: 0.
	arguments first compileInLine: encoder block: inBlock.
	encoder genHigh: 15 low: 5. " pop from stack "
	encoder genHigh: 15 low: 6. " branch "
	encoder genVal: start. " branch target "
	encoder patch: save.
	encoder genHigh: 5 low: 10  " push nil "]
compile: encoder test: t constant: c block: inBlock | save ssave | [
	super compile: encoder.
	encoder genHigh: 15 low: t.  " branch test "
	save <- encoder genVal: 0.
	arguments first compileInLine: encoder block: inBlock.
	encoder genHigh: 15 low: 6.  " branch "
	ssave <- encoder genVal: 0.
	encoder patch: save.
	encoder genHigh: 5 low: c.  " push constant "
	encoder patch: ssave]
optimizeIf: encoder block: inBlock | save ssave | [
	encoder genHigh: 15 low: 7.  " branch if true test "
	save <- encoder genVal: 0.
	arguments first compileInLine: encoder block: inBlock.
	arguments removeFirst.
	encoder genHigh: 15 low: 6.  " branch "
	ssave <- encoder genVal: 0.
	encoder patch: save.
	arguments first compileInLine: encoder block: inBlock.
	encoder patch: ssave]
]

MetaMessageNode [

]

